% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pulse_split.R
\name{pulse_split}
\alias{pulse_split}
\title{Split \code{pulse_data} across sequential time windows (\verb{STEP 2})}
\usage{
pulse_split(
  pulse_data,
  window_width_secs,
  window_shift_secs,
  min_data_points,
  with_progress = NULL,
  msg = TRUE
)
}
\arguments{
\item{pulse_data}{The output from a call to \code{pulse_read()}, which results in a list with two elements:
\itemize{
\item \verb{$data}, a tibble with one column with timestamps (named \code{time}) and one or more columns of numeric data (the voltage readings from each channel of the PULSE multi-channel system; all channels with unique names).
\item \verb{$freq}, a single integer value representing the sampling frequency used (in Hz).
}}

\item{window_width_secs}{A single numeric value indicating the width of the time windows (in seconds) over which heart rate frequency will later be computed.}

\item{window_shift_secs}{A single numeric value indicating by how much each subsequent window is shifted from the preceding one (in seconds).}

\item{min_data_points}{A single numeric value, expressed as a ratio \verb{[0, 1]}, used as a threshold to discard windows where data is missing (e.g., if the sampling frequency is \code{20} and \code{window_width_secs = 30}, each window should include \code{600} data points, and so if \code{min_data_points = 0.8}, windows with less than \code{600 * 0.8 = 480} data points will be rejected).}

\item{with_progress}{One of \code{TRUE}, \code{FALSE} or \code{NULL} (default) to choose whether to show progress bars or not (based on the \code{progressr} package). \code{TRUE} prints a \code{cli}-style progress bar; \code{FALSE} disables progress bars altogether; if set to \code{NULL}, the behavior is controlled by the user from outside this function (by setting the desired \code{handlers()}; in addition, setting \code{handlers(global = TRUE)} ensures the same behavior is used across the entire session).}

\item{msg}{A logical to decide if non-crucial messages (but not errors) are shown (defaults to \code{TRUE}; mainly for use from within the wrapper function \code{PULSE()}, where it is set to \code{FALSE} to avoid the repetition of identical messages)}
}
\value{
A list with all the valid time windows (i.e., complying with \code{min_data_points}), each window being a subset of \code{pulse_data} (a tibble with at least 2 columns (time + one or more channels) containing PULSE data with timestamps within that time window)
}
\description{
\itemize{
\item \verb{step 1} -- \code{\link[=pulse_read]{pulse_read()}}
\item \strong{\verb{-->>} step 2 -- \code{\link[=pulse_split]{pulse_split()}} \verb{<<--}}
\item \verb{step 3} -- \code{\link[=pulse_optimize]{pulse_optimize()}}
\item \verb{step 4} -- \code{\link[=pulse_heart]{pulse_heart()}}
}

After all raw PULSE data has been imported, the dataset must be split across sequential time windows.

\code{pulse_split()} takes the output from a call to \code{pulse_read()} and splits data across user-defined time windows. The output of \code{pulse_split()} can be immediately passed to \code{pulse_heart()}, or first optimized with \code{pulse_optimize()} and then passed to \code{pulse_heart()} (highly recommended).
}
\section{Details}{

\code{pulse_split()} takes the output from a call to \code{pulse_read()} and splits data across user-defined time windows.
}

\section{Window \code{width} and \code{shift}}{

A good starting point for \code{window_width_secs} is to set it to between \code{30} and \code{60} seconds.

As a rule of thumb, use lower values for data collected from animals with naturally faster heart rates and/or that have been subjected to treatments conducive to faster heart rates still (e.g., thermal performance ramps). In such cases, lower values will result in higher temporal resolution, which may be crucial if experimental conditions are changing rapidly. Conversely, experiments using animals with naturally slower heart rates and/or subjected to treatments that may cause heart rates to stabilize or even slow (e.g., control or cold treatments) may require the use of higher values for \code{window_width_secs}, as the resulting windows should encompass no less than 5-7 heartbeat cycles.

As for \code{window_shift_secs}, set it to a value:
\itemize{
\item smaller than \code{window_width_secs} if overlap between windows is desired (not usually recommended) (if \code{window_width_secs = 30} and \code{window_shift_secs = 15}, the first 3 windows will go from \verb{[0, 30)}, \verb{[15, 45)} and \verb{[30, 60)})
\item equal to \code{window_width_secs} to process all data avaliable (if \code{window_width_secs = 30} and \code{window_shift_secs = 30}, the first 3 windows will go from \verb{[0, 30)}, \verb{[30, 60)} and \verb{[60, 90)})
\item larger than \code{window_width_secs} to skip data (ideal for speeding up the processing of large datasets) (if \code{window_width_secs = 30} and \code{window_shift_secs = 60}, the first 3 windows will go from \verb{[0, 30)}, \verb{[60, 90)} and \verb{[120, 150)})
}

In addition, also consider that lower values for the \code{window_...} parameters may lead to oversampling and a cascade of statistical issues, the resolution of which may end up negating any advantage gained.
}

\section{Handling gaps in the dataset}{

\code{min_data_points} shouldn't be set too low, otherwise only nearly empty windows will be rejected.
}

\section{Speeding up for large datasets}{

Processing large PULSE multi-channel datasets can take a long time. All main \code{pulse_...()} functions are built to allow parallelization based on the \code{futures} package. To engage parallel computing, simply set an appropriate \code{future} strategy before running \code{pulse_split()} (or at the begining of the PULSE data processing pipeline to make it available for all \code{pulse_...()} functions). Unless explicitly modified by the user, \code{future::plan()} defaults to \code{sequential}, i.e., not pararellized. Call \code{future::plan("multisession")} to use one of the most common parallelized \code{future} strategies. Call \code{?future::plan} for additional details.
}

\examples{
# Begin prepare data ----
pulse_data_sub <- pulse_data
pulse_data_sub$data <- pulse_data_sub$data[,1:5]
# End prepare data ----

# Without parallel computation
pulse_data_split <- pulse_split(
   pulse_data_sub,
   window_width_secs = 30,
   window_shift_secs = 60,
   min_data_points = 0.8,
   with_progress = TRUE)

# With parallel computation
## Not Run:
# To engage parallel computing:
require(future)
future::plan() # check current future plan
old_plan <- future::plan("multisession") # set a parallelized future plan (and save the previous)

pulse_data_sub <- pulse_data
pulse_data_sub$data <- pulse_data_sub$data[,1:5]
pulse_data_split <- pulse_split(
   pulse_data_sub,
   window_width_secs = 30,
   window_shift_secs = 60,
   min_data_points = 0.8,
   with_progress = TRUE)

future::plan(old_plan) # reset future plan to the original value
future::plan() # confirm that the current future plan is set to the original value
## End Not Run
}
\seealso{
\code{\link[progressr:handlers]{progressr::handlers()}}, \code{\link[future:plan]{future::plan()}}

\code{\link[=pulse_read]{pulse_read()}}, \code{\link[=pulse_optimize]{pulse_optimize()}}, \code{\link[=pulse_heart]{pulse_heart()}}, \code{\link[=PULSE]{PULSE()}}
}
