% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pulse_optimize.R
\name{pulse_optimize}
\alias{pulse_optimize}
\title{Optimize PULSE data through interpolation and smoothing (\verb{STEP 3})}
\usage{
pulse_optimize(pulse_data_split, target_freq = 40, bandwidth = 0.2)
}
\arguments{
\item{pulse_data_split}{The output of \code{\link[=pulse_split]{pulse_split()}}, i.e., a list with PULSE data split across time windows, each window being a subset of \code{pulse_data} (a tibble with at least 2 columns (time + one or more channels) containing PULSE data with timestamps within that time window)}

\item{target_freq}{A numeric value expressing the frequency (in Hz) to which PULSE data should be interpolated. Can be set to \code{0} (zero) or any value equal or greater than \code{40} (the default). If set to zero, no interpolation is performed.}

\item{bandwidth}{A numeric value expressing the bandwidth. If equal to \code{0} (zero) no smoothing is applied. Ideally kept low (defaults to \code{0.2}) so that only very high frequency noise is removed, but can be pushed up all the way to \code{1} or above (especially when the heartbeat rate is expected to be slow, as is typical of oysters, but double check the resulting data). Type \code{?ksmooth} for additional info.}
}
\value{
The list with PULSE data split across time windows supplied in \code{pulse_data_split}, but now with data in each list element interpolated to \code{target_freq} (i.e., with more data points) and channels smoothed.
}
\description{
\itemize{
\item \verb{step 1} -- \code{\link[=pulse_read]{pulse_read()}}
\item \verb{step 2} -- \code{\link[=pulse_split]{pulse_split()}}
\item \strong{\verb{-->>} step 3 -- \code{\link[=pulse_optimize]{pulse_optimize()}} \verb{<<--}}
\item \verb{step 4} -- \code{\link[=pulse_heart]{pulse_heart()}}
}

IMPORTANT NOTE: \code{pulse_optimize()} can be skipped, but that is highly discouraged.

The performance of the algorithm employed in the downstream function \code{pulse_heart()} for the detection of heartbeat wave crests depends significantly on \code{(i)} there being a sufficient number of data points around each crest and \code{(ii)} the data not being too noisy. \code{pulse_optimize()} uses first \code{pulse_interpolate()} and then \code{pulse_smooth()} to reshape the data non-destructively and improve the likelihood of \code{pulse_heart()} successfully estimating the inherent heartbeat rates.
\itemize{
\item \code{INTERPOLATION} is highly recommended because tests on real data have shown that a frequency of at least 40 Hz is crucial to ensure wave crests can be discerned even when the underlying heartbeat rate is high (i.e., at rates above 2-3 Hz). Since the PULSE multi-channel system is not designed to capture data at such high rates (partially because it would generate files unnecessarily large), \code{pulse_interpolate()} is used instead to artificially increase the temporal resolution of the data by linearly interpolating to the target frequency. It is important to note that this process DOES NOT ALTER the shape of the heart beat wave, it just introduces intermediary data points. Also, the only downside to using very high values for \code{target_freq} is the proportional increase in computing time and size of the outputs together with minimal improvements in the performance of \code{pulse_heart()} - but no artefacts are expected.
\item \code{SMOOTHING} isn't as crucial, but should be experimented with when \code{pulse_heart()} produces too many heartbeat rate estimates that are clearly incorrect. In such situations, \code{pulse_smooth()} applies a smoothing filter (normal Kernel Regression Smoother) to the data to smooth out high-frequency noise and render a more sinusoidal wave, which is easier to handle. Unlike \code{target_freq}, users should exercise caution when setting \code{bandwidth} and generally opt for lower values, as there's a threshold to bandwidth values above which the resulting smoothed pulse data becomes completely unrelated to the original data, and the subsequent heartbeat rates computed with \code{pulse_heart()} will be totally wrong. Always double-check the data after applying a stronger smoothing. Note that if applied with the default \code{bandwidth}, smoothing incurs no penalty and hardly changes the data - so it isn't worth going out of the way to not apply smoothing.
}
}
\examples{
# Begin prepare data ----
pulse_data_sub <- pulse_data
pulse_data_sub$data <- pulse_data_sub$data[,1:5]
pulse_data_split <- pulse_split(
   pulse_data_sub,
   window_width_secs = 30,
   window_shift_secs = 60,
   min_data_points = 0.8,
   with_progress = TRUE)
# End prepare data ----

# Optimize data by interpolating to 40 Hz and applying a slight smoothing
pulse_optimize(pulse_data_split, 40, 0.2)
}
\seealso{
\itemize{
\item \code{\link[=approx]{approx()}} is used by \code{\link[=pulse_interpolate]{pulse_interpolate()}} for the linear interpolation of PULSE data
\item \code{\link[=ksmooth]{ksmooth()}} is used by \code{\link[=pulse_smooth]{pulse_smooth()}} for the kernel smoothing of PULSE data
\item \code{\link[=pulse_optimize]{pulse_optimize()}} is a wrapper function that executes \code{pulse_interpolate} and \code{pulse_smooth} sequentially
\item \code{\link[=pulse_read]{pulse_read()}}, \code{\link[=pulse_split]{pulse_split()}} and \code{\link[=pulse_heart]{pulse_heart()}} are the other functions needed for the complete PULSE processing workflow
\item \code{\link[=PULSE]{PULSE()}} is a wrapper function that executes all the steps needed to process PULSE data at once
}
}
